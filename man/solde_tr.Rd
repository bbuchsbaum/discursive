% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/solde_tr.R
\name{solde_tr}
\alias{solde_tr}
\title{Stable and Orthogonal Local Discriminant Embedding using Trace Ratio Criterion (SOLDE-TR)
with nanoflann-based k-NN for Fast Adjacency Construction}
\usage{
solde_tr(
  X,
  y,
  s = 5,
  alpha = 0.9,
  sigma = 1,
  m = 10,
  tol = 1e-06,
  maxit = 100,
  pca_preprocess = TRUE
)
}
\arguments{
\item{X}{A numeric matrix of size \eqn{N \times D} (row-wise samples).}

\item{y}{A numeric vector of length \eqn{N} (class labels).}

\item{s}{Number of neighbors for adjacency; default = 5.}

\item{alpha}{Numeric in \eqn{[0.5, 1]}. Balances \eqn{L_s} vs \eqn{L_v} in
\eqn{L_d = alpha * L_s - (1-alpha)*L_v}; default = 0.9.}

\item{sigma}{Positive scalar for the heat kernel \(\exp(-\|x_i - x_j\|^2 / \sigma)\); default = 1.0.}

\item{m}{Desired dimension of the subspace; default = 10.}

\item{tol}{Stopping threshold for change in trace ratio; default = 1e-6.}

\item{maxit}{Maximum number of ITR iterations; default = 100.}

\item{pca_preprocess}{Logical: whether to do PCA to ensure full rank; default = TRUE.}
}
\value{
A list with:
\item{\code{W_pca}}{The PCA projection matrix (columns are the top PCA components).}
\item{\code{W_solde_tr}}{The \eqn{m} projection vectors from the trace ratio solution in the PCA subspace.}
\item{\code{W}}{The final \eqn{D x m} projection matrix = \(\mathbf{W}\emph{{\mathrm{PCA}} \times \mathbf{W}}{\mathrm{SOLDE-TR}}\).}
\item{\code{eigvals_pca}}{Eigenvalues of the PCA step (if \code{pca_preprocess} = TRUE).}
\item{\code{trace_ratio_history}}{Vector of trace ratio values across ITR iterations.}
}
\description{
This is an extension of the SOLDE-TR algorithm described in:
\insertRef{yang2017stable}{}

The method extends the Stable Orthogonal Local Discriminant Embedding (SOLDE)
approach by recasting its objective function into a trace ratio optimization problem
and using an iterative trace-ratio (ITR) algorithm to jointly learn the orthogonal
projection vectors. Compared to the step-by-step SOLDE, SOLDE-TR converges faster,
yields a global solution, and usually provides improved performance in tasks such as
face recognition.

\strong{What is new in this version?}
We accelerate the adjacency graph construction (Steps 1--2 in Section 3 of the paper)
by using the \code{Rnanoflann} package, which provides a \code{nanoflann}-backed kd-tree
for extremely fast nearest neighbor (k-NN) queries. This can be a substantial improvement
over naive \eqn{O(N^2)} neighbor searches when \eqn{N} is large.

\strong{Correspondence to the Paper Sections:}
\itemize{
\item \strong{Equations (1), (2), (3):} Construction of adjacency (weight) matrices
\eqn{S}, \eqn{H}, \eqn{F} for similarity, diversity, and inter-class separability.
\item \strong{Equations (4)--(6):} Objective functions in local discriminant embedding.
\item \strong{Equation (7):} Combination into \eqn{L_d = \alpha L_s - (1-\alpha)L_v}.
\item \strong{Equations (11)--(16):} The trace ratio formulation and iterative algorithm.
}
}
\details{
Main steps:
\enumerate{
\item \strong{(Optional) PCA Projection:}
We project \eqn{X} into a PCA subspace to ensure \eqn{S_d} is nonsingular.

\item \strong{Build Adjacency Graphs with \code{Rnanoflann}:}
- \eqn{S} (similarity)
If two points \eqn{x_i} and \eqn{x_j} belong to the same class and either
\eqn{x_j} is among the \eqn{s} nearest neighbors of \eqn{x_i} \emph{or}
\eqn{x_i} is among the \eqn{s} neighbors of \eqn{x_j}, then
\eqn{S_{ij} = \exp(-\|x_i - x_j\|^2/\sigma)}.
- \eqn{H} (diversity)
Same condition (same-class neighbors), but \eqn{H_{ij} = 1 - \exp(-\|x_i - x_j\|^2/\sigma)}.
- \eqn{F} (interclass)
If \eqn{x_i} and \eqn{x_j} are from different classes \emph{and} they are in each
other's \eqn{s} neighborhoods (union condition),
then \eqn{F_{ij} = \exp(-\|x_i - x_j\|^2/\sigma)}.

\if{html}{\out{<div class="sourceCode">}}\preformatted{We implement this neighbor search using \code{nanoflann}'s kd-tree via \code{nn()} from
the \pkg{Rnanoflann} package for Euclidean distance.
}\if{html}{\out{</div>}}

\item \strong{Iterative Trace Ratio (ITR):}
Solve
\deqn{
      \max_{W^T W = I} \frac{\mathrm{tr}(W^T S_p W)}{\mathrm{tr}(W^T S_d W)},
    }
with \eqn{S_p = X L_m X^T} and \eqn{S_d = X L_d X^T}, via the iterative approach:
\eqn{\mathbf{M} = \mathbf{S_p} - \lambda \mathbf{S_d}}, eigen-decompose \(\mathbf{M}\),
pick the top \eqn{m} eigenvectors.  Update \(\lambda\), repeat until convergence.

\item \strong{Final Embedding:}
\eqn{\mathbf{W} = \mathbf{W}_{\mathrm{PCA}} \times \mathbf{W}_{\mathrm{SOLDE-TR}}}.
}
}
\examples{
\dontrun{
 # Simple test on a small dataset
 library(Rnanoflann)
 set.seed(1)
 N <- 100
 D <- 20
 X <- matrix(rnorm(N*D), nrow = N, ncol = D)
 y <- sample.int(3, size = N, replace = TRUE)

 solde_res <- SOLDE_TR_fastNN(X, y, s=5, alpha=0.9, sigma=1.0, m=8, tol=1e-5, maxit=50)
 # Project new data X_new:
 # Ynew <- t(solde_res$W) \%*\% t(X_new)
}
}
\references{
\enumerate{
\item Yang, X., Liu, G., Yu, Q., & Wang, R. (2017).
\emph{Stable and orthogonal local discriminant embedding using trace ratio criterion for dimensionality reduction.}
Pattern Recognition, 71, 249--264.
\item Wang, J., Zhu, X., & Gong, S. (2007).
\emph{ITR: Iterative trace ratio algorithm for feature extraction.}
IEEE Transactions on Knowledge and Data Engineering.
\item He, X., Yan, S., Hu, Y., Niyogi, P., & Zhang, H. (2005).
\emph{Face recognition using Laplacianfaces.}
IEEE Trans. on Pattern Analysis and Machine Intelligence.
\item \pkg{Rnanoflann} \url{https://github.com/ManosPapadakis95/Rnanoflann}
}
}
